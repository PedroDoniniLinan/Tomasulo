library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;                        

entity AdderMem is
  	generic(
		wordSize: natural :=32;
		n_cycles: natural := 4
	);
  port (
	 clock:    		in 	 std_logic; --! entrada de clock
	 reset:	 		in 	 std_logic; --! clear ass√≠ncrono
    r_n: in  std_logic_vector(wordSize-1 downto 0); 
	 data_address: in std_logic_vector(wordSize-1 downto 0);
	 start: in std_logic; -- input from ldstrQueue
    s    : out  std_logic_vector(wordSize-1 downto 0);
	 start_mem : out std_logic -- output to bufferMem
    );
end entity AdderMem;

architecture AdderMem of AdderMem is
signal counter : integer;
signal busy : std_logic;
begin

	process (reset, clock) -- caso qualquer entrada sofra alguma alteracao, inicia process
		variable temp : std_logic_vector(nbOfLines-1 downto 0);
		begin
		
			if reset = '1' then		 
				counter <= 0;
				start_mem <= 1;
				s <= (others => '0');
				
			elsif clock='1' and clock'event then
				s <= r_n + data_address;
				if start = '1' then
					busy <= '1'
					start_mem <= 0;					
				end if;
				
				if busy = '1' then
					counter <= counter + 1;					
				end if;
				
				if counter = n_cycles then
					busy <= 0;
					start_mem <= 1;
					counter <= 0;
				end if;
			end if;
end architecture AdderMem;
